Introduction To Data Structure 
Assignment 1
1.Write a C program to Print An Array.
#include <stdio.h>

int main() {
    // Define and initialize the array
    int array[] = {10, 20, 30, 40, 50};
    int length = sizeof(array) / sizeof(array[0]); // Calculate the number of elements in the array

    // Print the array elements
    printf("Array elements are:\n");
    for (int i = 0; i < length; i++) {
        printf("%d ", array[i]);
    }

    printf("\n"); // Print a newline for clean output
    return 0;
}
Output:Array elements are:
10 20 30 40 50 

2.Write a C program  to check whether a given string is Palindrome or not.
#include <stdio.h>
#include <string.h>
#include <ctype.h>  // For tolower() function

#define MAX_LENGTH 100

// Function to check if a string is a palindrome
int isPalindrome(char str[]) {
    int left = 0;
    int right = strlen(str) - 1;

    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !isalnum(str[left])) left++;
        while (left < right && !isalnum(str[right])) right--;

        // Compare characters
        if (tolower(str[left]) != tolower(str[right])) {
            return 0; // Not a palindrome
        }

        left++;
        right--;
    }

    return 1; // Is a palindrome
}

int main() {
    char str[MAX_LENGTH];

    // Input string from the user
    printf("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    // Remove newline character if present
    str[strcspn(str, "\n")] = 0;

    // Check if the string is a palindrome
    if (isPalindrome(str)) {
        printf("\"%s\" is a palindrome.\n", str);
    } else {
        printf("\"%s\" is not a palindrome.\n", str);
    }

    return 0;
}
Output-Enter a string: Racecar
"Racecar" is a palindrome.

3.Write a C program to convert temperature from degree Centrigrade to Fahrenheit.
#include <stdio.h>

int main() {
    float celsius, fahrenheit;

    // Input temperature in Celsius from the user
    printf("Enter temperature in Celsius: ");
    scanf("%f", &celsius);

    // Convert Celsius to Fahrenheit
    fahrenheit = (celsius * 9 / 5) + 32;

    // Display the result
    printf("%.2f Celsius is equal to %.2f Fahrenheit.\n", celsius, fahrenheit);

    return 0;
}
Output-Enter temperature in Celsius: 25
25.00 Celsius is equal to 77.00 Fahrenheit.

4.Write a C program to sort an array.
#include <stdio.h>

#define SIZE 10

void bubbleSort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j + 1]
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[SIZE] = {64, 34, 25, 12, 22, 11, 90, 45, 78, 56};
    
    printf("Original array:\n");
    printArray(arr, SIZE);

    bubbleSort(arr, SIZE);

    printf("Sorted array:\n");
    printArray(arr, SIZE);

    return 0;
}
5.Write a C program to print the largest and second largest element of the array.
#include <stdio.h>
#include <limits.h> // For INT_MIN

// Function to find the largest and second largest elements in an array
void findLargestAndSecondLargest(int arr[], int size, int *largest, int *secondLargest) {
    if (size < 2) {
        printf("Array must have at least two elements.\n");
        return;
    }

    *largest = INT_MIN;
    *secondLargest = INT_MIN;

    for (int i = 0; i < size; i++) {
        if (arr[i] > *largest) {
            *secondLargest = *largest;
            *largest = arr[i];
        } else if (arr[i] > *secondLargest && arr[i] != *largest) {
            *secondLargest = arr[i];
        }
    }

   
    if (*secondLargest == INT_MIN) {
        printf("No distinct second largest element found.\n");
    }
}

int main() {
    int arr[] = {12, 35, 1, 10, 34, 1};
    int size = sizeof(arr) / sizeof(arr[0]);
    int largest, secondLargest;

    findLargestAndSecondLargest(arr, size, &largest, &secondLargest);

    printf("Largest element is %d\n", largest);
    printf("Second largest element is %d\n", secondLargest);

    return 0;
}
Largest element is 35
Second largest element is 34
6.Write a C program to display the Fibonacci Series.
#include <stdio.h>


void printFibonacciSeries(int n) {
    if (n <= 0) {
        printf("The number of terms must be a positive integer.\n");
        return;
    }
    
   
    int first = 0, second = 1, next;

    
    printf("Fibonacci Series: %d", first);
    
    if (n > 1) {
        
        printf(", %d", second);
    }

   
    for (int i = 3; i <= n; i++) {
        next = first + second;
        printf(", %d", next);
        first = second;
        second = next;
    }
    
    printf("\n");
}

int main() {
    int terms;

   
    printf("Enter the number of terms in the Fibonacci series: ");
    scanf("%d", &terms);

   
    printFibonacciSeries(terms);

    return 0;
}
Enter the number of terms in the Fibonacci series: 10
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34

7.Write a C program to print the reverse array.
#include <stdio.h>


void reverseAndPrintArray(int arr[], int size) {
    printf("Reversed Array: ");
    
  
    for (int i = size - 1; i >= 0; i--) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]); // Calculate the number of elements in the array

   
    reverseAndPrintArray(arr, size);

    return 0;
}
Reversed Array: 5 4 3 2 1
8.Write a C program to check the sum of all elements pf an array.
#include <stdio.h>


int calculateSum(int arr[], int size) {
    int sum = 0;

   
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }

    return sum;
}

int main() {
    
    int arr[] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]); // Calculate the number of elements in the array

   
    int sum = calculateSum(arr, size);

   
    printf("Sum of all elements in the array: %d\n", sum);

    return 0;
}
Sum of all elements in the array: 150
9.Write a C program to check the duplicate number in array.
#include <stdio.h>
#include <stdbool.h>


bool hasDuplicates(int arr[], int size) {
   
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (arr[i] == arr[j]) {
                return true; // Duplicate found
            }
        }
    }
    return false; // No duplicates found
}

int main() {
 
    int arr[] = {1, 2, 3, 4, 5, 6, 3}; // You can change this to test different arrays
    int size = sizeof(arr) / sizeof(arr[0]); // Calculate the number of elements in the array

   
    if (hasDuplicates(arr, size)) {
        printf("The array contains duplicates.\n");
    } else {
        printf("The array does not contain any duplicates.\n");Wr
    }

    return 0;
}
int arr[] = {1, 2, 3, 4, 5, 6, 3};
The array contains duplicates.


Assignment-2
1.Write a C program to read a 2D array and then represent the same array as Sparse matrics.
#include <stdio.h>


void printSparseMatrix(int sparseMatrix[][3], int nonZeroCount) {
    printf("Sparse Matrix Representation:\n");
    printf("Row\tColumn\tValue\n");
    for (int i = 0; i < nonZeroCount; i++) {
        printf("%d\t%d\t%d\n", sparseMatrix[i][0], sparseMatrix[i][1], sparseMatrix[i][2]);
    }
}

int main() {
    int rows, cols;
    printf("Enter the number of rows and columns of the matrix: ");
    scanf("%d %d", &rows, &cols);

    int matrix[rows][cols];
    printf("Enter the elements of the matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

   
    int nonZeroCount = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] != 0) {
                nonZeroCount++;
            }
        }
    }

   
    int sparseMatrix[nonZeroCount][3];
    int index = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] != 0) {
                sparseMatrix[index][0] = i;
                sparseMatrix[index][1] = j;
                sparseMatrix[index][2] = matrix[i][j];
                index++;
            }
        }
    }

    // Print the sparse matrix representation
    printSparseMatrix(sparseMatrix, nonZeroCount);

    return 0;
}
Enter the number of rows and columns of the matrix: 4 4
Enter the elements of the matrix:
0 0 3 0
0 0 0 4
5 0 0 0
0 6 0 0
Sparse Matrix Representation:
Row    Column Value
0      2      3
1      3      4
2      0      5
3      1      6

2.Write a C program to Pass an array to function using Call by Value update the array values in the function print the array elements both in the function and in the calling function.
#include <stdio.h>

// Function to update array elements
void updateArray(int arr[], int size) {
    // Update array values
    for (int i = 0; i < size; i++) {
        arr[i] += 10; // Example update: add 10 to each element
    }

    // Print the array elements inside the function
    printf("Array elements inside the function:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    // Define and initialize the array
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]); // Calculate the number of elements in the array

    // Print the array elements before calling the function
    printf("Array elements before function call:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Call the function to update the array
    updateArray(arr, size);

    // Print the array elements after calling the function
    printf("Array elements after function call:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
Array elements before function call:
1 2 3 4 5 
Array elements inside the function:
11 12 13 14 15 
Array elements after function call:
11 12 13 14 15 

3.Write a C program  to pass an array to a function using  Call by Refernce update the array values  in the function print the array elements both in the function and in the calling function.
#include <stdio.h>

// Function to update array elements by reference
void updateArray(int *arr, int size) {
    // Update array values
    for (int i = 0; i < size; i++) {
        arr[i] += 10; // Example update: add 10 to each element
    }

    // Print the array elements inside the function
    printf("Array elements inside the function:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    // Define and initialize the array
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]); // Calculate the number of elements in the array

    // Print the array elements before calling the function
    printf("Array elements before function call:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Call the function to update the array
    updateArray(arr, size);

    // Print the array elements after calling the function
    printf("Array elements after function call:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
Array elements before function call:
1 2 3 4 5 
Array elements inside the function:
11 12 13 14 15 
Array elements after function call:
11 12 13 14 15 
4.Write a program that reads 2D matrices from the console verifies if metrices multiplication is possible or not.Then multiplies the matrices and prints the 3rd metrices.
#include <stdio.h>

// Function to read a matrix
void readMatrix(int matrix[][10], int rows, int cols) {
    printf("Enter the elements of the matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
}

// Function to print a matrix
void printMatrix(int matrix[][10], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// Function to multiply two matrices
void multiplyMatrices(int mat1[][10], int mat2[][10], int res[][10], int r1, int c1, int r2, int c2) {
    // Initialize result matrix to 0
    for (int i = 0; i < r1; i++) {
        for (int j = 0; j < c2; j++) {
            res[i][j] = 0;
        }
    }

    // Perform matrix multiplication
    for (int i = 0; i < r1; i++) {
        for (int j = 0; j < c2; j++) {
            for (int k = 0; k < c1; k++) {
                res[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }
}

int main() {
    int mat1[10][10], mat2[10][10], res[10][10];
    int r1, c1, r2, c2;

    // Read dimensions and matrices
    printf("Enter the number of rows and columns for the first matrix: ");
    scanf("%d %d", &r1, &c1);
    printf("Enter the number of rows and columns for the second matrix: ");
    scanf("%d %d", &r2, &c2);

    if (c1 != r2) {
        printf("Matrix multiplication is not possible. The number of columns of the first matrix must be equal to the number of rows of the second matrix.\n");
        return 1;
    }

    printf("Enter the elements of the first matrix:\n");
    readMatrix(mat1, r1, c1);

    printf("Enter the elements of the second matrix:\n");
    readMatrix(mat2, r2, c2);

    // Multiply matrices
    multiplyMatrices(mat1, mat2, res, r1, c1, r2, c2);

    // Print the result matrix
    printf("Resultant matrix after multiplication:\n");
    printMatrix(res, r1, c2);

    return 0;
}
Enter the number of rows and columns for the first matrix: 2 3
Enter the number of rows and columns for the second matrix: 3 2
Enter the elements of the first matrix:
1 2 3
4 5 6
Enter the elements of the second matrix:
7 8
9 10
11 12
Resultant matrix after multiplication:
58 64
139 154

5.Write a program that reads a 2D metrices and checks if the metrices is a symmetric metrics or not.
#include <stdio.h>
#include <stdbool.h>

// Function to read a matrix
void readMatrix(int matrix[][10], int rows, int cols) {
    printf("Enter the elements of the matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
}

// Function to print a matrix
void printMatrix(int matrix[][10], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// Function to check if a matrix is symmetric
bool isSymmetric(int matrix[][10], int size) {
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            if (matrix[i][j] != matrix[j][i]) {
                return false; // Matrix is not symmetric
            }
        }
    }
    return true; // Matrix is symmetric
}

int main() {
    int matrix[10][10];
    int rows, cols;

    // Read matrix dimensions
    printf("Enter the number of rows and columns of the matrix: ");
    scanf("%d %d", &rows, &cols);

    // Check if matrix is square
    if (rows != cols) {
        printf("Matrix is not square, hence it cannot be symmetric.\n");
        return 1;
    }

    // Read the matrix
    printf("Enter the elements of the matrix:\n");
    readMatrix(matrix, rows, cols);

    // Print the matrix
    printf("The entered matrix is:\n");
    printMatrix(matrix, rows, cols);

    // Check if the matrix is symmetric
    if (isSymmetric(matrix, rows)) {
        printf("The matrix is symmetric.\n");
    } else {
        printf("The matrix is not symmetric.\n");
    }

    return 0;
}
Enter the number of rows and columns of the matrix: 3 3
Enter the elements of the matrix:
1 2 3
2 4 5
3 5 6
The entered matrix is:
1 2 3
2 4 5
3 5 6
The matrix is symmetric.
6.Write a program to display a number of elements.Memory should be allocated dynamically using malloc().
#include <stdio.h>
#include <stdlib.h> // For malloc() and free()

int main() {
    int *arr; // Pointer to hold the dynamically allocated array
    int num_elements;

    // Read the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &num_elements);

    // Allocate memory for the array dynamically
    arr = (int *)malloc(num_elements * sizeof(int));

    // Check if memory allocation was successful
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit the program with an error code
    }

    // Initialize the array with some values (for demonstration)
    for (int i = 0; i < num_elements; i++) {
        arr[i] = i + 1; // Just filling with numbers 1, 2, ..., num_elements
    }

    // Display the number of elements
    printf("The number of elements is: %d\n", num_elements);

    // Display the elements of the array
    printf("Array elements are:\n");
    for (int i = 0; i < num_elements; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Free the allocated memory
    free(arr);

    return 0;
}
Enter the number of elements: 5
The number of elements is: 5
Array elements are:
1 2 3 4 5 
7.Write a program to display n number of elements. Memory should be allocated
dynamically using calloc( ).
#include <stdio.h>
#include <stdlib.h> // For calloc() and free()

int main() {
    int *arr; // Pointer to hold the dynamically allocated array
    int num_elements;

    // Read the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &num_elements);

    // Allocate memory for the array dynamically using calloc
    arr = (int *)calloc(num_elements, sizeof(int));

    // Check if memory allocation was successful
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit the program with an error code
    }

    // Initialize the array with values
    printf("Enter %d elements:\n", num_elements);
    for (int i = 0; i < num_elements; i++) {
        scanf("%d", &arr[i]);
    }

    // Display the number of elements
    printf("The number of elements is: %d\n", num_elements);

    // Display the elements of the array
    printf("Array elements are:\n");
    for (int i = 0; i < num_elements; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Free the allocated memory
    free(arr);

    return 0;
}
Enter the number of elements: 4
Enter 4 elements:
10
20
30
40
The number of elements is: 4
Array elements are:
10 20 30 40 
8.Write a program to allocate memory using malloc ( ) and then reallocate the previously
allocated memory using realloc( ). Display the elements which have been taken after
reallocation.
#include <stdio.h>
#include <stdlib.h> // For malloc(), realloc(), free()

int main() {
    int *arr; // Pointer to hold the dynamically allocated array
    int initial_size, new_size;
// Read the initial number of elements
    printf("Enter the initial number of elements: ");
    scanf("%d", &initial_size);

    // Allocate memory for the array dynamically using malloc
    arr = (int *)malloc(initial_size * sizeof(int));

   
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit the program with an error code
    }

   
    printf("Enter %d initial elements:\n", initial_size);
    for (int i = 0; i < initial_size; i++) {
        scanf("%d", &arr[i]);
    }

    
    printf("Initial array elements:\n");
    for (int i = 0; i < initial_size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

 
    printf("Enter the new number of elements (greater than or equal to %d): ", initial_size);
    scanf("%d", &new_size);

 
    arr = (int *)realloc(arr, new_size * sizeof(int));

   
    if (arr == NULL) {
        printf("Memory reallocation failed.\n");
        return 1; // Exit the program with an error code
    }

   
    if (new_size > initial_size) {
        printf("Enter %d additional elements:\n", new_size - initial_size);
        for (int i = initial_size; i < new_size; i++) {
            scanf("%d", &arr[i]);
        }
    }

   
    printf("Array elements after reallocation:\n");
    for (int i = 0; i < new_size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

  
    free(arr);

    return 0;
}
Enter the initial number of elements: 3
Enter 3 initial elements:
1 2 3
Initial array elements:
1 2 3 
Enter the new number of elements (greater than or equal to 3): 5
Enter 2 additional elements:
4 5
Array elements after reallocation:
1 2 3 4 5 
9.. Write a program to allocate memory using calloc( ) and then reallocate the previously
allocated memory using realloc( ). Display the elements which have been taken after realloaction.
#include <stdio.h>
#include <stdlib.h> // For calloc(), realloc(), free()

int main() {
    int *arr; // Pointer to hold the dynamically allocated array
    int initial_size, new_size;

  
    printf("Enter the initial number of elements: ");
    scanf("%d", &initial_size);

    
    arr = (int *)calloc(initial_size, sizeof(int));

  
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit the program with an error code
    }

   
    printf("Enter %d initial elements:\n", initial_size);
    for (int i = 0; i < initial_size; i++) {
        scanf("%d", &arr[i]);
    }

   
    printf("Initial array elements:\n");
    for (int i = 0; i < initial_size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

   
    printf("Enter the new number of elements (greater than or equal to %d): ", initial_size);
    scanf("%d", &new_size);

    
    arr = (int *)realloc(arr, new_size * sizeof(int));

    
    if (arr == NULL) {
        printf("Memory reallocation failed.\n");
        return 1; // Exit the program with an error code
    }

    
    if (new_size > initial_size) {
        printf("Enter %d additional elements:\n", new_size - initial_size);
        for (int i = initial_size; i < new_size; i++) {
            scanf("%d", &arr[i]);
        }
    }

   
    printf("Array elements after reallocation:\n");
    for (int i = 0; i < new_size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

  
    free(arr);

    return 0;
}
Enter the initial number of elements: 3
Enter 3 initial elements:
1 2 3
Initial array elements:
1 2 3 
Enter the new number of elements (greater than or equal to 3): 5
Enter 2 additional elements:
4 5
Array elements after reallocation:
1 2 3 4 5 
10.Write a C program to search an element in an Array using dynamic memory allocation.
#include <stdio.h>
#include <stdlib.h> // For malloc(), free()


int searchElement(int *arr, int size, int key) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == key) {
            return i; // Return the index where the element is found
        }
    }
    return -1; // Return -1 if the element is not found
}

int main() {
    int *arr;       // Pointer to hold the dynamically allocated array
    int num_elements, key, index;

  
    printf("Enter the number of elements: ");
    scanf("%d", &num_elements);

  
    arr = (int *)malloc(num_elements * sizeof(int));

   
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // Exit the program with an error code
    }

   
    printf("Enter %d elements:\n", num_elements);
    for (int i = 0; i < num_elements; i++) {
        scanf("%d", &arr[i]);
    }

   
    printf("Enter the element to search: ");
    scanf("%d", &key);

    
    index = searchElement(arr, num_elements, key);

    
    if (index != -1) {
        printf("Element %d found at index %d.\n", key, index);
    } else {
        printf("Element %d not found in the array.\n", key);
    }

   
    free(arr);

    return 0;
}
Enter the number of elements: 5
Enter 5 elements:
10
20
30
40
50
Enter the element to search: 60
Element 60 not found in the array.

Assignment-3
1.Write a Menu driven C program to accomplish  the following functionalities in single linked list.
a.Create a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;           // Data stored in the node
    struct Node* next;  // Pointer to the next node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node at the end of the linked list
void insert(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    // If the list is empty, make the new node the head
    if (*head == NULL) {
        *head = newNode;
        return;
    }

    // Otherwise, find the last node and insert the new node
    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Function to print the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list
    
    insert(&head, 10);  // Insert data into the list
    insert(&head, 20);
    insert(&head, 30);

    display(head);  // Output: 10 -> 20 -> 30 -> NULL

    return 0;
}
Output-10 -> 20 -> 30 -> NULL

b.Display the elements of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node at the end of the linked list
void insert(struct Node** head, int data) {
    struct Node* newNode = createNode(data);

    if (*head == NULL) {
        *head = newNode;
        return;
    }

    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    insert(&head, 10);  // Insert elements into the list
    insert(&head, 20);
    insert(&head, 30);

    display(head);  // Output: 10 -> 20 -> 30 -> NULL

    return 0;
}
Output=10 -> 20 -> 30 -> NULL
c.Insert a node at the beginning of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node at the beginning of the linked list
void insertAtBeginning(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    newNode->next = *head;  // New node points to the old head
    *head = newNode;        // The head now points to the new node
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes at the
Output-10 -> 20 -> 30 -> NULL
d.Insert a node at the beginning of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node at the beginning of the linked list
void insertAtBeginning(struct Node** head, int data) {
    struct Node* newNode = createNode(data);  // Create a new node
    newNode->next = *head;  // New node's next points to the current head
    *head = newNode;  // Head is updated to the new node
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes at the beginning
    insertAtBeginning(&head, 30);  // List becomes: 30 ->
Output-10 -> 20 -> 30 -> NULL
e.Insert a node before a given node of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node before a given node
void insertBefore(struct Node** head, int targetData, int newData) {
    struct Node* newNode = createNode(newData);  // Create the new node

    // Case 1: List is empty
    if (*head == NULL) {
        printf("List is empty.\n");
        return;
    }

    // Case 2: Target node is the head
    if ((*head)->data == targetData) {
        newNode->next = *head;
        *head = newNode;
        return;
    }

    // Case 3: Find the target node
    struct Node* current = *head;
    struct Node* previous = NULL;

    while (current != NULL && current->data != targetData) {
        previous = current;
        current = current->next;
    }

    // If the target node is not found
    if (current == NULL) {
        printf("Node with data %d not found.\n", targetData);
        free(newNode);
        return;
    }

    // Insert the new node before the target node
    previous->next = newNode;
    newNode->next = current;
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Insert before a given node
    insertBefore(&head, 30, 25);  // Insert 25 before 30
    printf("After inserting 25 before 30: ");
    display(head);  // Output: 10 -> 20 -> 25 -> 30 -> 40 -> NULL

    insertBefore(&head, 10, 5);   // Insert 5 before 10 (head)
    printf("After inserting 5 before 10: ");
    display(head);  // Output: 5 -> 10 -> 20 -> 25 -> 30 -> 40 -> NULL

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After inserting 25 before 30: 10 -> 20 -> 25 -> 30 -> 40 -> NULL
After inserting 5 before 10: 5 -> 10 -> 20 -> 25 -> 30 -> 40 -> NULL

f.Insert a node after a given node of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a new node after a given node
void insertAfter(struct Node* givenNode, int newData) {
    if (givenNode == NULL) {
        printf("The given node cannot be NULL.\n");
        return;
    }

    struct Node* newNode = createNode(newData);  // Create the new node
    newNode->next = givenNode->next;  // New node's next points to the given node's next
    givenNode->next = newNode;  // Given node's next points to the new node
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Insert after a given node
    insertAfter(head->next, 25);  // Insert 25 after 20
    printf("After inserting 25 after 20: ");
    display(head);  // Output: 10 -> 20 -> 25 -> 30 -> 40 -> NULL

    insertAfter(head->next->next->next, 35);  // Insert 35 after 30
    printf("After inserting 35 after 30: ");
    display(head);  // Output: 10 -> 20 -> 25 -> 30 -> 35 -> 40 -> NULL

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After inserting 25 after 20: 10 -> 20 -> 25 -> 30 -> 40 -> NULL
After inserting 35 after 30: 10 -> 20 -> 25 -> 30 -> 35 -> 40 -> NULL

g.Delete a node from the beginning of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to delete a node from the beginning of the linked list
void deleteFromBeginning(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty. No node to delete.\n");
        return;
    }

    struct Node* temp = *head;  // Store the current head
    *head = (*head)->next;      // Update head to the next node
    free(temp);                 // Free the memory of the old head
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Delete a node from the beginning
    deleteFromBeginning(&head);
    printf("After deleting the first node: ");
    display(head);  // Output: 20 -> 30 -> 40 -> NULL

    deleteFromBeginning(&head);
    printf("After deleting another node: ");
    display(head);  // Output: 30 -> 40 -> NULL

    deleteFromBeginning(&head);
    printf("After deleting another node: ");
    display(head);  // Output: 40 -> NULL

    deleteFromBeginning(&head);
    printf("After deleting another node: ");
    display(head);  // Output: List is empty. No node to delete.

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After deleting the first node: 20 -> 30 -> 40 -> NULL
After deleting another node: 30 -> 40 -> NULL
After deleting another node: 40 -> NULL
After deleting another node: List is empty. No node to delete.

h.Delete a node from the end of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to delete a node from the end of the linked list
void deleteFromEnd(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty. No node to delete.\n");
        return;
    }

    // Case when there is only one node
    if ((*head)->next == NULL) {
        free(*head);  // Free the single node
        *head = NULL; // Update head to NULL
        return;
    }

    struct Node* current = *head;
    struct Node* previous = NULL;

    // Traverse to the second-to-last node
    while (current->next != NULL) {
        previous = current;
        current = current->next;
    }

    // Now, previous points to the second-to-last node
    previous->next = NULL;  // Update the next pointer of the second-to-last node
    free(current);          // Free the last node
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Delete a node from the end
    deleteFromEnd(&head);
    printf("After deleting the last node: ");
    display(head);  // Output: 10 -> 20 -> 30 -> NULL

    deleteFromEnd(&head);
    printf("After deleting another node: ");
    display(head);  // Output: 10 -> 20 -> NULL

    deleteFromEnd(&head);
    printf("After deleting another node: ");
    display(head);  // Output: 10 -> NULL

    deleteFromEnd(&head);
    printf("After deleting another node: ");
    display(head);  // Output: List is empty. No node to delete.

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After deleting the last node: 10 -> 20 -> 30 -> NULL
After deleting another node: 10 -> 20 -> NULL
After deleting another node: 10 -> NULL
After deleting another node: List is empty. No node to delete.

i.Delete a node after a given node of a single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to delete a node after a given node
void deleteAfter(struct Node* givenNode) {
    if (givenNode == NULL) {
        printf("The given node cannot be NULL.\n");
        return;
    }

    // Check if there is a node to delete after the given node
    struct Node* nodeToDelete = givenNode->next;
    if (nodeToDelete == NULL) {
        printf("No node to delete after the given node.\n");
        return;
    }

    // Adjust pointers and free memory
    givenNode->next = nodeToDelete->next;  // Skip the node to be deleted
    free(nodeToDelete);                     // Free the memory of the deleted node
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Delete the node after a given node
    deleteAfter(head);  // Delete the node after 10
    printf("After deleting the node after 10: ");
    display(head);  // Output: 10 -> 30 -> 40 -> NULL

    deleteAfter(head->next);  // Delete the node after 30
    printf("After deleting the node after 30: ");
    display(head);  // Output: 10 -> 30 -> NULL

    // Try to delete after the last node
    deleteAfter(head->next);  // Attempt to delete after 30
    printf("After trying to delete after 30: ");
    display(head);  // Output: 10 -> 30 -> NULL

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After deleting the node after 10: 10 -> 30 -> 40 -> NULL
After deleting the node after 30: 10 -> 30 -> NULL
No node to delete after the given node.
After trying to delete after 30: 10 -> 30 -> NULL

j.Delete a entire single linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to delete the entire linked list
void deleteList(struct Node** head) {
    struct Node* current = *head;
    struct Node* nextNode;

    while (current != NULL) {
        nextNode = current->next; // Store the next node
        free(current);            // Free the current node
        current = nextNode;       // Move to the next node
    }

    *head = NULL; // Update head to NULL to indicate the list is empty
}

// Function to display elements of the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty list

    // Insert nodes manually
    head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printf("Original List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> NULL

    // Delete the entire linked list
    deleteList(&head);
    printf("After deleting the entire list: ");
    display(head);  // Output: NULL

    return 0;
}
Output-Original List: 10 -> 20 -> 30 -> 40 -> NULL
After deleting the entire list: NULL


2.Write a Menu driven C program to accomplish the following functionalities in circular linked list.
a.Create a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        *head = newNode;  // If the list is empty, set the new node as head
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        while (temp->next != *head) {
            temp = temp->next; // Traverse to the last node
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point new node to head
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    return 0;
}
Output-Circular Linked List: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

b.Display the elements of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        *head = newNode;  // If the list is empty, set the new node as head
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        while (temp->next != *head) {
            temp = temp->next; // Traverse to the last node
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point new node to head
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    return 0;
}
Output-Circular Linked List: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
c.Insert a node at the beginning of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the circular linked list
void insertBeginning(struct Node** head, int data) {
    struct Node* newNode = createNode(data);

    if (*head == NULL) {
        *head = newNode;  // If the list is empty, set the new node as head
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        
        newNode->next = *head; // Point new node to current head
        temp->next = newNode;   // Link the last node to the new node
        *head = newNode;        // Update head to the new node
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertBeginning(&head, 20);
    insertBeginning(&head, 30);
    insertBeginning(&head, 10); // Inserting at the beginning
    insertBeginning(&head, 40);

    printf("Circular Linked List after insertions: ");
    display(head);  // Output: 40 -> 10 -> 20 -> 30 -> (back to head: 40)

    return 0;
}
Output-Circular Linked List after insertions: 40 -> 10 -> 20 -> 30 -> (back to head: 40)
d.Insert a node at the end of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        // If the list is empty, set the new node as head
        *head = newNode;
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point the new node to head
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List after insertions: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    return 0;
}
Output-Circular Linked List after insertions: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
e.Delete a node from the beginning of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        // If the list is empty, set the new node as head
        *head = newNode;
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point the new node to head
    }
}

// Function to delete a node from the beginning of the circular linked list
void deleteBeginning(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty. No nodes to delete.\n");
        return;
    }
    
    struct Node* temp = *head;
    
    // If there's only one node in the list
    if (temp->next == *head) {
        free(temp); // Free the only node
        *head = NULL; // Update head to NULL
    } else {
        struct Node* last = *head;
        // Find the last node
        while (last->next != *head) {
            last = last->next;
        }
        // Update head and the last node's next pointer
        *head = temp->next; // Move head to the next node
        last->next = *head; // Update the last node's next to new head
        free(temp); // Free the old head
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List before deletion: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    // Delete a node from the beginning
    deleteBeginning(&head);
    printf("Circular Linked List after deleting the beginning node: ");
    display(head);  // Output: 20 -> 30 -> 40 -> (back to head: 20)

    return 0;
}
Output-Circular Linked List before deletion: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
Circular Linked List after deleting the beginning node: 20 -> 30 -> 40 -> (back to head: 20)

f.Delete a node from the end of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        // If the list is empty, set the new node as head
        *head = newNode;
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point the new node to head
    }
}

// Function to delete a node from the end of the circular linked list
void deleteEnd(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty. No nodes to delete.\n");
        return;
    }
    
    struct Node* temp = *head;
    
    // If there's only one node in the list
    if (temp->next == *head) {
        free(temp); // Free the only node
        *head = NULL; // Update head to NULL
    } else {
        struct Node* prev = NULL;
        // Traverse to the last node
        while (temp->next != *head) {
            prev = temp;
            temp = temp->next;
        }
        // Update the second-to-last node's next pointer
        prev->next = *head; // Point it to head
        free(temp); // Free the last node
    }
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List before deletion: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    // Delete a node from the end
    deleteEnd(&head);
    printf("Circular Linked List after deleting the last node: ");
    display(head);  // Output: 10 -> 20 -> 30 -> (back to head: 10)

    return 0;
}
Output-Circular Linked List before deletion: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
Circular Linked List after deleting the last node: 10 -> 20 -> 30 -> (back to head: 10)
g.Delete a node after a given node of a circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        // If the list is empty, set the new node as head
        *head = newNode;
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point the new node to head
    }
}

// Function to delete a node after a given node
void deleteAfterNode(struct Node* head, struct Node* givenNode) {
    if (head == NULL || givenNode == NULL || givenNode->next == head) {
        printf("No node to delete after the given node.\n");
        return;
    }

    struct Node* temp = givenNode->next;
    if (temp == head) {
        // If the next node is the head, update the next pointer of the given node
        givenNode->next = head; // Set the given node's next to head
    } else {
        givenNode->next = temp->next; // Bypass the node to be deleted
    }

    free(temp); // Free the node to be deleted
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List before deletion: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    // Deleting a node after the first node
    deleteAfterNode(head, head); // Delete node after head (which is 20)
    printf("Circular Linked List after deleting node after head: ");
    display(head);  // Output: 10 -> 30 -> 40 -> (back to head: 10)

    return 0;
}
Output-Circular Linked List before deletion: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
Circular Linked List after deleting node after head: 10 -> 30 -> 40 -> (back to head: 10)
h.Delete a entire circular linked list.
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the circular linked list
void insertEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    
    if (*head == NULL) {
        // If the list is empty, set the new node as head
        *head = newNode;
        newNode->next = *head; // Point it to itself
    } else {
        struct Node* temp = *head;
        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = newNode; // Link the last node to the new node
        newNode->next = *head; // Point the new node to head
    }
}

// Function to delete an entire circular linked list
void deleteList(struct Node** head) {
    if (*head == NULL) {
        printf("List is empty. No nodes to delete.\n");
        return;
    }

    struct Node* current = *head;
    struct Node* nextNode;

    // Traverse the list and free each node
    do {
        nextNode = current->next; // Store the next node
        free(current); // Free the current node
        current = nextNode; // Move to the next node
    } while (current != *head);

    *head = NULL; // Set head to NULL after deletion
    printf("All nodes deleted successfully.\n");
}

// Function to display elements of the circular linked list
void display(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head: %d)\n", head->data);
}

// Example usage
int main() {
    struct Node* head = NULL;  // Initialize an empty circular linked list

    // Insert nodes into the circular linked list
    insertEnd(&head, 10);
    insertEnd(&head, 20);
    insertEnd(&head, 30);
    insertEnd(&head, 40);

    printf("Circular Linked List before deletion: ");
    display(head);  // Output: 10 -> 20 -> 30 -> 40 -> (back to head: 10)

    // Delete the entire circular linked list
    deleteList(&head);
    printf("Circular Linked List after deletion: ");
    display(head);  // Output: List is empty.

    return 0;
}
Output-Circular Linked List before deletion: 10 -> 20 -> 30 -> 40 -> (back to head: 10)
All nodes deleted successfully.
Circular Linked List after deletion: List is empty.



















